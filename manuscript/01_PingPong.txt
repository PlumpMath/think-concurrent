
# Warming up: Ping-Pong

The classical "Ping-Pong" example is somehow to concurrency what the infamous "Hello World!" is to sequential programming. It is a minimal system that still exposes some key features of (here concurrent) programs:

  - there's **concurrency**: there is a Ping *and* a there is a Pong,

  - there's **interaction**: the Ping talks to the Pong and *vice-versa*,

  - there's **no termination**: use your `Ctrl-C` to stop the program.

But still similarly to its sequential welcoming cousin: this is *not* a deeply interesting example, so it's perfect to focus on the *compile-and-run* issues.

Technically-speaking, the system we are going to build consists in two *threads* that exchange and print Ping-Pong messages through *channels*. Here they are! the two "big" words have been shouted out:

> a **system** is composed of **threads** that exchange messages through **channels**.

That's pretty much summarize what (an major part of) `core.async` is all about !

But first things first, let us write our first `core.async` example. The namespace specification is the following one.

{crop-start-line=6,crop-end-line=8}
<<[pingpong.clj](code/think-concurrent/src/think_concurrent/pingpong.clj)

The `clojure.core.async` namespace provides is where the main API resides. Since it's in the core it is fairly common to `refer` the main functionalities, especially the cryptic ones such as `>!!` (blocking send) and `<!!` (blocking receive).

Now, the behavior of both our threads can be specified as a single function:

{crop-start-line=10,crop-end-line=17}
<<(code/think-concurrent/src/think_concurrent/pingpong.clj)


