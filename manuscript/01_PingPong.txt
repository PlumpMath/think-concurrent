
# Warming up: Ping-Pong

The classical "Ping-Pong" example is somehow to concurrency what the infamous "Hello World!" is to sequential programming. It is a minimal system that still exposes some key features of (here concurrent) programs:

  - there's **concurrency**: there is a Ping *and* a there is a Pong,

  - there's **interaction**: the Ping talks to the Pong and *vice-versa*,

  - there's **no termination**: use your `Ctrl-C` to stop the program.

But still similarly to its sequential welcoming cousin: this is *not* a deeply interesting example, so it's perfect to focus on the *compile-and-run* issues.

Technically-speaking, the system we are going to build consists in two *threads* that exchange and print Ping-Pong messages through *channels*. Here they are! the "big" words have been shouted out.

A> A **system** is composed of **threads** that exchange messages through **channels**.

That's pretty much summarize what (an major part of) *core.async* is all about !

But first things first, let us write our first *core.async* example. The namespace specification is the following one.

{crop-start-line=6,crop-end-line=8}
<<[pingpong.clj](code/think-concurrent/src/think_concurrent/pingpong.clj)

The `clojure.core.async` namespace provides is where the main API resides. Since it's in the core it is fairly common to `refer` the main functionalities, especially the cryptic ones such as `>!!` (blocking send) and `<!!` (blocking receive).

Now, the behavior of both our threads can be specified as a single function:

{crop-start-line=10,crop-end-line=17}
<<[pingpong.clj (cont'd)](code/think-concurrent/src/think_concurrent/pingpong.clj)

The first two parameters are intended to be the two communication channels on which the thread interact:

  - the channel `in`  for receiving messages

  - the channel `out` for sending messages

The parameter `kind` indicates the message that the thread will emit: either `"Ping ! "` or `"Pong ! "`. The `thread` primitive of *core.async* is used to spawn a new ... guess what ? ... *thread* of course ! In *clojure* this means a JVM thread hence what we shall call a *heavy thread* in this book. The body of `thread` will thus be executer in parallel with the caller thread, *parallelism* you go! We next enter a loop consisting in indefinitely repeating the following sequence.

1. First, in the expression:

    {lang="clojure"}
        (let [msg (<!! in)]
          ;; do something with msg
          ...)

    the current thread listens on channel `in` and *blocks*  until a message `msg` can be received.

2. Then, with:

    {lang="clojure"}
        (print msg) (flush)

    the thread print the message upon reception (note the `flush` for safer -- but not completely safe -- outputs).

3. Finally, with:

    {lang="clojure"}
        (>!! out kind)

    the thread *blocks* until it can send on channel `out` its own `kind` of message: `"Ping ! "` if we're the *pinger*, `"Pong ! "` if we're the *ponger*.

4.  And finally we `recur` for good.

I> ## Blocking send and receive actions on **synchronous channels**
I> The fundamental characteristic of the send and receive operations is that they are potentially *blocking*. Using the default *synchronous channels* the blocking semantics is as follows:
I>
I>  - a thread performing a receive action  `(<!! ch)`  (receiving on channel `ch`)  is blocking until another thread performs a corresponding send action `(>!! ch value)`, i.e. sending some `value` on the *same* channel `ch`,
I>  - and `vice-versa`.

The creation of a synchronous channel is the responsability of the `chan` primitive of *core.async*.  A typical expression involving `chan` is of the form:

{land="clojure"}
    (let [ch (chan)]
      ;; ... let's use the channel ch
	
We have now everything we need to create our first complete, although overally useless, *core.async* program.

{crop-start-line=19,crop-end-line=26}
<<[pingpong.clj (cont'd)](code/think-concurrent/src/think_concurrent/pingpong.clj)

The `run-ping-pong` function first creates two synchronous channels: `ping` and `pong` and also calls the `ping-pong` thread-creating function twice. The first call is to spawn the *pinger* which waits on channel `ping` and sends `"Ping! "` messages on channel `pong`  (hence towards the *ponger*). The second call for the *ponger* uses the same channel `pong` as input, and sends on `ping` thus closing the cycle.

Q> ## What? Side-effects?
Q> Clojurians promote side-effect-free code using higher-order functions,
Q> immutable (GC'ed) datastructures and so on (think *transducers* ...) *as long as this makes sense* !
Q> Concurrency is (unlike parallel computing) pretty much about side-effects: creating processes/threads,
Q> sending messages, waiting/blocking, etc. Hence, *core.async* is no silver-bullet and most of its
Q> primitive involve one form or another of side effects. We will see, though, that higher-level
Q> and apparently side-effect-free constructions can be build *atop* the *core.async* primitives,
Q>  for example based on *dataflow* architectures.

We notice that the *ping-pong* function return values are exploited in the example.

I> ## The `thread` primitive and joining
I> An expression of the form:
I>
I> `(thread` *<body>*`)`
I>
I> creates as a side-effect a system-level thread running the *<body>* expression, and
I> returns immediately with a *read-only* synchronous channel that can be used
I> to *join* the thread, i.e. wait for its *termination*.

The system is started by sending a first message `"Start!"` to channel `ping`  (we could of course use `pong` instead, can you guess the change in behavior?).  Finally, we join the *pinger* thread so that the main thread does not terminate *too early*.

To actually run the example, we can either:

  - start a `repl`  (using `lein repl`) and type

        => (run-ping-pong)

    at the prompt[^run], or

    [^run] : the `think-concurrent.core` namespace require all the main functions of the examples.

- directly launch the example with `lein run pingpong` [^ex]

  [^ex] : all the examples can be tried using `lein run` $<example>$  with $<example>$ probably as you could guess.

Let's try the second solution:

~~~~~~~~
$ lein run pingpong
--------------------------------------------
Example: pingpong
--------------------------------------------
Start! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! ... and this can continue for some time ...
~~~~~~~~

... at some point I suggest that you hit the `Ctrl-C` key (or reboot on windows ?).

In the spirit of many multi-threaded programs (e.g. web servers, database engines, etc.) our PingPong example does not terminate!  We might wonder why, then, we join the threads since they do not terminate themselves.  This is of course to ensure that the main thread, the one spawning the two PingPong threads, does *also* not terminate.  If we remove the join operation (by commenting out the last line, without forgetting to close the parentheses), the trace becomes as follows:

~~~~~~~~
--------------------------------------------
Example: pingpong
--------------------------------------------
Start! Ping! 
~~~~~~~~

Oops, that's it the main thread already terminated !

