
# Warming up: Ping-Pong

The classical "Ping-Pong" example is somehow to concurrency what the infamous "Hello World!" is to sequential programming. It is a minimal system that still exposes some key features of (here concurrent) programs:

  - there's **parallelism**: there is a Ping *and* a there is a Pong,

  - there's **interaction**: the Ping talks to the Pong and *vice-versa*,

  - there's **non-determinism**: this will sprinkle with *pain* over the *joy*,

  - there's **no termination**: use your `Ctrl-C` to stop the program.

But still similarly to its sequential welcoming cousin: this is *not* a deeply interesting example, so it's perfect to focus on the *compile-and-run* issues.

Technically-speaking, the system we are going to build consists in two *threads* that exchange and print Ping-Pong messages through *channels*. Here they are! the "big" words have been shouted out.

A> A **system** is composed of **threads** that exchange messages through **channels**.

That's pretty much summarize what (an major part of) *core.async* is all about !

## Version 1: the tireless ping-pong players

But first things first, let us write our first *core.async* example. The namespace specification is the following one.

{crop-start-line=6,crop-end-line=8}
<<[pingpong.clj](code/think-concurrent/src/think_concurrent/pingpong.clj)

The `clojure.core.async` namespace provides is where the main API resides. Since it's in the core it is fairly common to `refer` the main functionalities, especially the cryptic ones such as `>!!` (blocking send) and `<!!` (blocking receive).

Now, the behavior of both our threads can be specified as a single function:

{crop-start-line=10,crop-end-line=16}
<<[pingpong.clj (cont'd)](code/think-concurrent/src/think_concurrent/pingpong.clj)

The first parameter is intended to be a communication channel on which the thread interact.
The parameter `kind` indicates the message that the thread will emit: either `"Ping ! "` or `"Pong ! "`.

The `thread` primitive of *core.async* is used to spawn a new ... guess what ? ... *thread* of course ! In *clojure* this means a JVM thread hence what we shall call a *heavy thread* in this book. The body of `thread` will thus be executed in parallel with the caller thread, *parallelism* you go! We next enter a loop consisting in indefinitely repeating the following sequence.

1. First, in the expression:

    {lang="clojure"}
        (let [msg (<!! ch)]
          ;; do something with msg
          ...)

    the current thread listens on channel `ch` and *blocks*  until a message `msg` can be received.

2. Then, with:

    {lang="clojure"}
        (print msg) (flush)

    the thread print the message upon reception (note the `flush` for safer -- but not completely safe -- outputs).

3. Finally, with:

    {lang="clojure"}
        (>!! ch kind)

    the thread *blocks* until it can send on channel `ch` its own `kind` of message: `"Ping ! "` if we're the *pinger*, `"Pong ! "` if we're the *ponger*.

4.  And finally we `recur` for good.

I> ## Blocking send and receive actions on **synchronous channels**
I> The fundamental characteristic of the send and receive operations is that they are potentially *blocking*. Using the default *synchronous channels* the blocking semantics is as follows:
I>
I>  - a thread performing a receive action  `(<!! ch)`  (receiving on channel `ch`)  is blocking until another thread performs a corresponding send action `(>!! ch value)`, i.e. sending some `value` on the *same* channel `ch`,
I>  - and `vice-versa`.

The creation of a synchronous channel is the responsability of the `chan` primitive of *core.async*.  A typical expression involving `chan` is of the form:

{land="clojure"}
    (let [ch (chan)]
      ;; ... let's use the channel ch
	
We have now everything we need to create our first complete, although overally useless, *core.async* program.

{crop-start-line=18,crop-end-line=24}
<<[pingpong.clj (cont'd)](code/think-concurrent/src/think_concurrent/pingpong.clj)

The `run-ping-pong` function first creates the synchronous channel `ch` used for the interactions. It then calls the `ping-pong` thread-creating function twice to spawn the *pinger* and *ponger* threads.

Q> ## What? Side-effects?
Q> Clojurians promote side-effect-free code using higher-order functions,
Q> immutable (GC'ed) datastructures and so on (think *transducers* ...) *as long as this makes sense* !
Q> Concurrency is (unlike parallel computing) pretty much about side-effects: creating processes/threads,
Q> sending messages, waiting/blocking, etc. Hence, *core.async* is no silver-bullet and most of its
Q> primitive involve one form or another of side effects. We will see, though, that higher-level
Q> and apparently side-effect-free constructions can be build *atop* the *core.async* primitives,
Q>  for example based on *dataflow* architectures.

We notice that the *ping-pong* function return values are exploited in the example.

I> ## The `thread` primitive and joining
I> An expression of the form:
I>
I> `(thread` *<body>*`)`
I>
I> creates as a side-effect a system-level thread running the *<body>* expression, and
I> returns immediately with a *read-only* synchronous channel that can be used
I> to *join* the thread, i.e. wait for its *termination*.

The system is started by sending a first message `"Start!"` to channel `ch`.  Finally, we join the *pinger* thread so that the main thread does not terminate *too early*.

To actually run the example, we can either:

  - start a `repl`  (using `lein repl`) and type

        => (run-ping-pong)

    at the prompt[^run], or

    [^run]: the `think-concurrent.core` namespace require all the main functions of the examples.

- directly launch the example with `lein run pingpong` [^ex]

  [^ex]: all the examples can be tried using `lein run` $<example>$  with $<example>$ probably as you could guess.

Let's try the second solution:

~~~~~~~~
$ lein run pingpong
--------------------------------------------
Example: pingpong
--------------------------------------------
Start! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! ... and this can continue for some time ...
~~~~~~~~

... at some point I suggest that you hit the `Ctrl-C` key (or reboot on windows ?).

In the spirit of many multi-threaded programs (e.g. web servers, database engines, etc.) our PingPong example does not terminate!  We might wonder why, then, we join the threads since they do not terminate themselves.  This is of course to ensure that the main thread, the one spawning the two PingPong threads, does *also* not terminate.  If we remove the join operation (by commenting out the last line, without forgetting to close the parentheses), the trace becomes as follows:

~~~~~~~~
--------------------------------------------
Example: pingpong
--------------------------------------------
Start! Ping! 
~~~~~~~~

Oops, that's it the main thread already terminated !

## Version 2: the gas-guzzlers with a paddle

Of course, not *all* concurrent programs are non-terminating, but let's say that if non-termination is a show-stopper for sequential programs, it is a *feature* of many concurrent programs.

So let's modify slightly the Ping-Pong example so that it predictibly terminates. One idea to make thread self-terminating is to provide them with some fuel, and force the thread termination when it's exhausted (I hope you're not!).

{crop-start-line=27,crop-end-line=34}
<<[pingpong.clj (cont'd)](code/think-concurrent/src/think_concurrent/pingpong.clj)

The *runner* is modified accordingly.

{crop-start-line=36,crop-end-line=44}
<<[pingpong.clj (cont'd)](code/think-concurrent/src/think_concurrent/pingpong.clj)

Let's start the system at the repl this time:

~~~~~~~~
$ lein repl
nREPL server started on port 53047 on host 127.0.0.1 - nrepl://127.0.0.1:53047
REPL-y 0.3.5, nREPL 0.2.10
Clojure 1.7.0
Java HotSpot(TM) 64-Bit Server VM 1.8.0-b132

   ... etc ...

=> (run-pingpong-fuel 10)
Start! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Joined!
nil
=> (run-pingpong-fuel 5)
Start! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Joined!
nil
~~~~~~~~

This is what you may obtain if you're lucky enough (which means: most of the time!).
If you're unlucky (which means: rarely enough!) you could see something more like this:

~~~~~~~~
=> (run-pingpong-fuel 10)
Start! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong! Ping! Pong!
~~~~~~~~

Here, the system does *not* terminate because the *pinger* blocks at some point and the join on channel `j` in fact never occurs (and in this case you have type hit `Ctrl-C`).  What happens is that the *ponger* thread sees its fuel exhausted too soon. Look at the trace: the first message is `Pong!` and not `Ping!` as in the other cases. This may occur because the first send `(>!! ch "Start! ")` is *non-deterministic*. It will either awake the *pinger*  or the *ponger* (and the `(Thread/sleep 100)` is here to make sure this *actually* happens). If the *ponger* starts, then it's last action will be to send it's `fuel`-th message. At the other end the *pinger* will receive the message for the `fuel`-th time.  But then there is no one to synchronize with since the *ponger* terminated. When the *pinger* is started first, we reach a situation where only the *ponger* remains blocked. But this is not a problem since we join the *pinger* in the runner.

I told you: *non-determinism* sometimes bites, and when it does ... that hurts !

Q> ## Non-determinism ?
Q> A sequential program is most of the time *deterministic*: provided we provide
Q> the same input, two distinct executions of the same program will produce the same result.
Q> It is even a stronger requirement for the *pure functional* parts.
Q> A concurrent program is often (but not always!) *non-deterministic*: provided with the
Q> same input, two distinct executions can produce very different outcomes.
Q> Is this a feature we should desire or fear? I would say both. On the one hand, *non-determinism*
Q> is often the price to pay for the tremendous gain of performances offered by
Q> concurrent programs on parallel hardware. On the other hand, this is a major source
Q> of bugs that are extremely difficult to track-down, and whose effects can be
Q> disastrous. Frameworks such as `core.async` offer ways to control *non-determinism*
Q> thanks to powerfull abstractions. But we shouldn't be too naive, this is a
Q> difficult issue with no [silver bullet](https://en.wikipedia.org/wiki/No_Silver_Bullet).

So, how do we solve this issue ? One way that preserves *non-determinism* (in many situations this is what we want!) is to give an extra gallon of fuel for the *ponger*. If the *pinger* terminates first it will be blocked before exhaustion anyway, and the extra fuel will allow the *pinger* to terminate properly.

E> ## The deterministic Ping-Pong
E> Another, more robust solution would be to modify the program so that the initialisation becomes deterministic.
E> An idea is to split the `pingpong-fuel` definition in two, and only allows e.g. the *pinger* to start first.



